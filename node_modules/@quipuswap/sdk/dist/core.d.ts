import BigNumber from "bignumber.js";
import { TezosToolkit } from "@taquito/taquito";
import { Asset, Token, Factories, StrictFactories, TransferParams, ContractOrAddress } from "./types";
import { FoundDex } from "./helpers";
export declare function swap(tezos: TezosToolkit, factories: Factories, fromAsset: Asset, toAsset: Asset, value: BigNumber.Value, slippageTolerance?: BigNumber.Value, toAccount?: string): Promise<TransferParams[]>;
export declare function estimateSwap(tezos: TezosToolkit, factories: Factories, fromAsset: Asset, toAsset: Asset, values: {
    inputValue: BigNumber.Value;
} | {
    outputValue: BigNumber.Value;
}, dexes?: {
    inputDex?: FoundDex;
    outputDex?: FoundDex;
}): Promise<BigNumber>;
export declare function initializeLiquidity(tezos: TezosToolkit, factories: StrictFactories, token: Token, tokenValue: BigNumber.Value, tezValue: BigNumber.Value): Promise<TransferParams[]>;
export declare function addLiquidity(tezos: TezosToolkit, dex: FoundDex | ContractOrAddress, values: {
    tokenValue: BigNumber.Value;
    tezValue: BigNumber.Value;
} | {
    tokenValue: BigNumber.Value;
} | {
    tezValue: BigNumber.Value;
}): Promise<TransferParams[]>;
export declare function removeLiquidity(tezos: TezosToolkit, dex: FoundDex | ContractOrAddress, lpTokenValue: BigNumber.Value, slippageTolerance: BigNumber.Value): Promise<TransferParams[]>;
export declare function getLiquidityShare(tezos: TezosToolkit, dex: FoundDex | ContractOrAddress, account: string): Promise<{
    unfrozen: BigNumber;
    frozen: BigNumber;
    total: BigNumber;
}>;
export declare function estimateReward(tezos: TezosToolkit, dex: FoundDex | ContractOrAddress, account: string): Promise<BigNumber>;
export declare function withdrawReward(tezos: TezosToolkit, dex: FoundDex | ContractOrAddress, receiver: string): Promise<TransferParams[]>;
export declare function voteForBaker(tezos: TezosToolkit, dex: FoundDex | ContractOrAddress, bakerAddress: string, lpTokenValue: BigNumber.Value): Promise<TransferParams[]>;
export declare function vetoCurrentBaker(tezos: TezosToolkit, dex: FoundDex | ContractOrAddress, lpTokenValue: BigNumber.Value): Promise<TransferParams[]>;
export declare function toLPToken(dex: ContractOrAddress, dexStorage: any): Token;
export declare function getDexToken(dexStorage: any): Token;
export declare function isDexExistAndContainsLiquidity(tezos: TezosToolkit, factories: Factories, token: Token): Promise<boolean>;
export declare function findDexNonStrict(tezos: TezosToolkit, factories: Factories, token: Token): Promise<FoundDex | null>;
export declare function findDex(tezos: TezosToolkit, { fa1_2Factory, fa2Factory }: Factories, token: Token): Promise<FoundDex>;
export declare function toFoundDex(tezos: TezosToolkit, dex: FoundDex | ContractOrAddress): Promise<FoundDex>;
export declare function withTokenApprove(tezos: TezosToolkit, token: Token, from: string, to: string, value: BigNumber.Value, transfers: TransferParams[]): Promise<TransferParams[]>;
export declare function chooseDex(a: FoundDex, b: FoundDex): number;
/**
 * Errors
 */
export declare class DexNotFoundError implements Error {
    name: string;
    message: string;
}
export declare class DexAlreadyContainsLiquidity implements Error {
    name: string;
    message: string;
}
export declare class DexNotContainsLiquidity implements Error {
    name: string;
    message: string;
}
