(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taquito/http-utils'), require('@taquito/michelson-encoder'), require('@taquito/utils'), require('@taquito/taquito'), require('bignumber.js'), require('crypto-js')) :
    typeof define === 'function' && define.amd ? define(['exports', '@taquito/http-utils', '@taquito/michelson-encoder', '@taquito/utils', '@taquito/taquito', 'bignumber.js', 'crypto-js'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.taquitoTzip16 = {}, global.httpUtils, global.michelsonEncoder, global.utils, global.taquito, global.BigNumber, global.CryptoJS));
}(this, (function (exports, httpUtils, michelsonEncoder, utils, taquito, BigNumber, CryptoJS) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var BigNumber__default = /*#__PURE__*/_interopDefaultLegacy(BigNumber);
    var CryptoJS__default = /*#__PURE__*/_interopDefaultLegacy(CryptoJS);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }

    var HttpHandler = /** @class */ (function () {
        function HttpHandler() {
            this.httpBackend = new httpUtils.HttpBackend();
        }
        HttpHandler.prototype.getMetadata = function (_contractAbstraction, _a, _context) {
            var protocol = _a.protocol, location = _a.location;
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_b) {
                    return [2 /*return*/, this.httpBackend.createRequest({
                            url: protocol + ":" + decodeURIComponent(location),
                            method: 'GET',
                            mimeType: "text; charset=utf-8",
                            json: false
                        })];
                });
            });
        };
        return HttpHandler;
    }());

    var BigMapMetadataNotFound = /** @class */ (function () {
        function BigMapMetadataNotFound() {
            this.name = 'BigMapMetadataNotFound';
            this.message = 'Non-compliance with the TZIP-016 standard. No big map named metadata was found in the contract storage.';
        }
        return BigMapMetadataNotFound;
    }());
    var MetadataNotFound = /** @class */ (function () {
        function MetadataNotFound(info) {
            this.info = info;
            this.name = 'MetadataNotFound';
            this.message = "No metadata was found in the contract storage. " + info;
        }
        return MetadataNotFound;
    }());
    var UriNotFound = /** @class */ (function () {
        function UriNotFound() {
            this.name = 'UriNotFound';
            this.message = 'Non-compliance with the TZIP-016 standard. No URI found in the contract storage.';
        }
        return UriNotFound;
    }());
    var InvalidUri = /** @class */ (function () {
        function InvalidUri(uri) {
            this.uri = uri;
            this.name = 'InvalidUri';
            this.message = "Non-compliance with the TZIP-016 standard. The URI is invalid: " + uri + ".";
        }
        return InvalidUri;
    }());
    var InvalidMetadata = /** @class */ (function () {
        function InvalidMetadata(invalidMetadata) {
            this.invalidMetadata = invalidMetadata;
            this.name = 'InvalidMetadata';
            this.message = "The metadata found at the pointed ressource are not compliant with tzip16 standard: " + invalidMetadata + ".";
        }
        return InvalidMetadata;
    }());
    var ProtocolNotSupported = /** @class */ (function () {
        function ProtocolNotSupported(protocol) {
            this.protocol = protocol;
            this.name = 'ProtocolNotSupported';
            this.message = "The protocol found in the URI is not supported: " + protocol + ".";
        }
        return ProtocolNotSupported;
    }());
    var InvalidMetadataType = /** @class */ (function () {
        function InvalidMetadataType() {
            this.name = 'InvalidMetadataType';
            this.message = 'The contract does not comply with the tzip16 standard. The type of metadata should be bytes.';
        }
        return InvalidMetadataType;
    }());
    var UnconfiguredMetadataProviderError = /** @class */ (function () {
        function UnconfiguredMetadataProviderError() {
            this.name = 'UnconfiguredMetadataProviderError';
            this.message = 'No metadata provider has been configured. The default one can be configured by calling addExtension(new Tzip16Module()) on your TezosToolkit instance.';
        }
        return UnconfiguredMetadataProviderError;
    }());
    var ForbiddenInstructionInViewCode = /** @class */ (function () {
        function ForbiddenInstructionInViewCode(instruction) {
            this.instruction = instruction;
            this.name = 'ForbiddenInstructionInViewCode';
            this.message = "Error found in the code of the view. It contains a forbidden instruction: " + instruction + ".";
        }
        return ForbiddenInstructionInViewCode;
    }());
    var NoParameterExpectedError = /** @class */ (function () {
        function NoParameterExpectedError(viewName, args) {
            this.viewName = viewName;
            this.args = args;
            this.name = 'NoParameterExpectedError';
            this.message = viewName + " Received " + args.length + " arguments while expecting no parameter or 'Unit'";
        }
        return NoParameterExpectedError;
    }());
    var InvalidViewParameterError = /** @class */ (function () {
        function InvalidViewParameterError(viewName, sigs, args) {
            this.viewName = viewName;
            this.sigs = sigs;
            this.args = args;
            this.name = 'InvalidViewParameterError';
            this.message = viewName + " Received " + args.length + " arguments while expecting one of the following signatures (" + JSON.stringify(sigs) + ")";
        }
        return InvalidViewParameterError;
    }());

    var typeOfValueToFind = {
        prim: 'big_map',
        args: [{ prim: 'string' }, { prim: 'bytes' }],
        annots: ['%metadata']
    };
    var TezosStorageHandler = /** @class */ (function () {
        function TezosStorageHandler() {
            this.TEZOS_STORAGE_REGEX = /^(?:\/\/(KT1\w{33})(?:\.(.+))?\/)?([\w|\%]+)$/;
        }
        TezosStorageHandler.prototype.getMetadata = function (contractAbstraction, _a, context) {
            var location = _a.location;
            return __awaiter(this, void 0, void 0, function () {
                var parsedTezosStorageUri, storage, bigMapId, bytes;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            parsedTezosStorageUri = this.parseTezosStorageUri(location);
                            if (!parsedTezosStorageUri) {
                                throw new InvalidUri("tezos-storage:" + location);
                            }
                            return [4 /*yield*/, context.rpc.getScript(parsedTezosStorageUri.contractAddress || contractAbstraction.address)];
                        case 1:
                            storage = _b.sent();
                            bigMapId = michelsonEncoder.Schema.fromRPCResponse({ script: storage }).FindFirstInTopLevelPair(storage.storage, typeOfValueToFind);
                            if (!bigMapId) {
                                throw new BigMapMetadataNotFound();
                            }
                            return [4 /*yield*/, context.contract.getBigMapKeyByID(bigMapId['int'].toString(), parsedTezosStorageUri.path, new michelsonEncoder.Schema(typeOfValueToFind))];
                        case 2:
                            bytes = _b.sent();
                            if (!bytes) {
                                throw new MetadataNotFound("No '" + parsedTezosStorageUri.path + "' key found in the big map %metadata of the contract " + (parsedTezosStorageUri.contractAddress || contractAbstraction.address));
                            }
                            if (!/^[0-9a-fA-F]*$/.test(bytes)) {
                                throw new InvalidMetadataType();
                            }
                            return [2 /*return*/, utils.bytes2Char(bytes)];
                    }
                });
            });
        };
        /**
         * @description Extract the smart contract address, the network and the path pointing to the metadata from the uri
         * @returns an object which contains the properties allowing to find where the metadata are located or it returns undefined if the uri is not valid
         * @param tezosStorageURI URI (without the tezos-storage prefix)
         */
        TezosStorageHandler.prototype.parseTezosStorageUri = function (tezosStorageURI) {
            var extractor = this.TEZOS_STORAGE_REGEX.exec(tezosStorageURI);
            if (!extractor)
                return;
            return {
                contractAddress: extractor[1],
                network: extractor[2],
                path: decodeURIComponent(extractor[3])
            };
        };
        return TezosStorageHandler;
    }());

    var IpfsHttpHandler = /** @class */ (function () {
        function IpfsHttpHandler(ipfsGatheway) {
            this._httpBackend = new httpUtils.HttpBackend();
            this._ipfsGateway = ipfsGatheway ? ipfsGatheway : 'ipfs.io';
        }
        IpfsHttpHandler.prototype.getMetadata = function (_contractAbstraction, _a, _context) {
            var location = _a.location;
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_b) {
                    return [2 /*return*/, this._httpBackend.createRequest({
                            url: "https://" + this._ipfsGateway + "/ipfs/" + location.substring(2) + "/",
                            method: 'GET',
                            headers: { 'Content-Type': 'text/plain' },
                            mimeType: "text; charset=utf-8",
                            json: false
                        })];
                });
            });
        };
        return IpfsHttpHandler;
    }());

    exports.ViewImplementationType = void 0;
    (function (ViewImplementationType) {
        ViewImplementationType["MICHELSON_STORAGE"] = "michelsonStorageView";
        ViewImplementationType["REST_API_QUERY"] = "restApiQuery";
    })(exports.ViewImplementationType || (exports.ViewImplementationType = {}));

    var MichelsonStorageView = /** @class */ (function () {
        function MichelsonStorageView(viewName, contract, rpc, returnType, code, viewParameterType) {
            this.viewName = viewName;
            this.contract = contract;
            this.rpc = rpc;
            this.returnType = returnType;
            this.code = code;
            this.viewParameterType = viewParameterType;
            this.validateArgs = function (args, schema, viewName) {
                var sigs = schema.ExtractSignatures();
                if (!sigs.find(function (x) { return x.length === args.length; })) {
                    throw new InvalidViewParameterError(viewName, sigs, args);
                }
            };
        }
        /**
         * @description According to the tzip-16 standard, the following instructions must not be used in the code of the view:
         * 'AMOUNT', 'CREATE_CONTRACT', 'SENDER', 'SET_DELEGATE', 'SOURCE', and 'TRANSFER_TOKENS'
         * The method throw an error if an illegal instruction is found
         */
        MichelsonStorageView.prototype.findForbiddenInstructionInViewCode = function (code) {
            var e_1, _a, e_2, _b;
            var illegalInstructions = [
                'AMOUNT',
                'CREATE_CONTRACT',
                'SENDER',
                'SET_DELEGATE',
                'SOURCE',
                'TRANSFER_TOKENS'
            ];
            try {
                for (var illegalInstructions_1 = __values(illegalInstructions), illegalInstructions_1_1 = illegalInstructions_1.next(); !illegalInstructions_1_1.done; illegalInstructions_1_1 = illegalInstructions_1.next()) {
                    var forbiddenInstruction = illegalInstructions_1_1.value;
                    try {
                        for (var code_1 = (e_2 = void 0, __values(code)), code_1_1 = code_1.next(); !code_1_1.done; code_1_1 = code_1.next()) {
                            var instruction = code_1_1.value;
                            if (instruction.prim === forbiddenInstruction) {
                                throw new ForbiddenInstructionInViewCode(forbiddenInstruction);
                            }
                            if (instruction.args && instruction.args.length !== 0) {
                                this.findForbiddenInstructionInViewCode(instruction.args);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (code_1_1 && !code_1_1.done && (_b = code_1.return)) _b.call(code_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (illegalInstructions_1_1 && !illegalInstructions_1_1.done && (_a = illegalInstructions_1.return)) _a.call(illegalInstructions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        /**
         * @description According to the tzip-16 standard, in the first version of the specification, the instruction SELF should only be used before ADDRESS
         * The method throws an error is the instruction SELF is present, but not followed by ADDRESS
         */
        MichelsonStorageView.prototype.illegalUseOfSelfInstruction = function (code) {
            var e_3, _a;
            try {
                for (var code_2 = __values(code), code_2_1 = code_2.next(); !code_2_1.done; code_2_1 = code_2.next()) {
                    var instruction = code_2_1.value;
                    if (instruction.prim === 'SELF') {
                        var index = code.indexOf(instruction);
                        var nextInstruction = code[index + 1] ? code[index + 1].prim : undefined;
                        if (nextInstruction !== 'ADDRESS') {
                            throw new ForbiddenInstructionInViewCode('the instruction SELF should only be used before ADDRESS');
                        }
                    }
                    if (instruction.args && instruction.args.length !== 0) {
                        this.illegalUseOfSelfInstruction(instruction.args);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (code_2_1 && !code_2_1.done && (_a = code_2.return)) _a.call(code_2);
                }
                finally { if (e_3) throw e_3.error; }
            }
        };
        /**
         * @description Loops through the view's code and replace SELF, BALANCE, NOW, and CHAIN_ID with Michelson expressions that match the current context, if applicable.
         */
        MichelsonStorageView.prototype.adaptViewCodeToContext = function (code, contractBalance, blockTimeStamp, chainId) {
            var _this = this;
            var instructionsToReplace = {
                SELF: [
                    { prim: 'PUSH', args: [{ prim: 'address' }, { string: this.contract.address }] },
                    { prim: 'CONTRACT', args: [{ prim: 'unit' }] },
                    { prim: 'IF_NONE', args: [[{ prim: 'UNIT' }, { prim: 'FAILWITH' }], []] }
                ],
                BALANCE: [{ prim: 'PUSH', args: [{ prim: 'mutez' }, { int: contractBalance }] }],
                NOW: [{ prim: 'PUSH', args: [{ prim: 'timestamp' }, { string: blockTimeStamp }] }],
                CHAIN_ID: [{ prim: 'PUSH', args: [{ prim: 'string' }, { string: chainId }] }]
            };
            code.forEach(function (x, i) {
                for (var instruction in instructionsToReplace) {
                    if (x.prim === instruction) {
                        code[i] = Object(instructionsToReplace)[instruction];
                    }
                    if (x.args && x.args.length !== 0) {
                        _this.adaptViewCodeToContext(x.args, contractBalance, blockTimeStamp, chainId);
                    }
                }
            });
            return code;
        };
        MichelsonStorageView.prototype.formatArgsAndParameter = function (argView) {
            var args = argView;
            var viewParameterType = this.viewParameterType;
            if (!viewParameterType) {
                viewParameterType = { args: [], prim: 'unit', annots: [] };
            }
            if (viewParameterType.prim === 'unit') {
                if (args.length === 0) {
                    args = ['Unit'];
                }
                if (args.length !== 0 && args[0] !== 'Unit') {
                    throw new NoParameterExpectedError(this.viewName, argView);
                }
            }
            var parameterViewSchema = new michelsonEncoder.ParameterSchema(viewParameterType);
            this.validateArgs(args, parameterViewSchema, this.viewName);
            var arg = parameterViewSchema.Encode.apply(parameterViewSchema, __spreadArray([], __read(args)));
            return { arg: arg, viewParameterType: viewParameterType };
        };
        MichelsonStorageView.prototype.executeView = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return __awaiter(this, void 0, void 0, function () {
                var _a, arg, viewParameterType, storageType, storageArgs, storageValue, chainId, contractBalance, block, blockTimestamp, code, viewScript, result, viewResultSchema;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // validate view code against tzip-16 specifications
                            this.findForbiddenInstructionInViewCode(this.code);
                            this.illegalUseOfSelfInstruction(this.code);
                            _a = this.formatArgsAndParameter(args), arg = _a.arg, viewParameterType = _a.viewParameterType;
                            storageType = this.contract.script.code.find(function (x) { return x.prim === 'storage'; });
                            storageArgs = storageType.args[0];
                            storageValue = this.contract.script.storage;
                            return [4 /*yield*/, this.rpc.getChainId()];
                        case 1:
                            chainId = _b.sent();
                            return [4 /*yield*/, this.rpc.getBalance(this.contract.address)];
                        case 2:
                            contractBalance = (_b.sent()).toString();
                            return [4 /*yield*/, this.rpc.getBlock()];
                        case 3:
                            block = _b.sent();
                            blockTimestamp = block.header.timestamp.toString();
                            code = this.adaptViewCodeToContext(this.code, contractBalance, blockTimestamp, chainId);
                            if (!this.viewParameterType) {
                                code.unshift({ prim: 'CDR' });
                            }
                            viewScript = {
                                script: [
                                    { prim: 'parameter', args: [{ prim: 'pair', args: [viewParameterType, storageArgs] }] },
                                    { prim: 'storage', args: [{ prim: 'option', args: [this.returnType] }] },
                                    {
                                        prim: 'code',
                                        args: [
                                            [
                                                { prim: 'CAR' },
                                                code,
                                                { prim: 'SOME' },
                                                { prim: 'NIL', args: [{ prim: 'operation' }] },
                                                { prim: 'PAIR' }
                                            ]
                                        ]
                                    }
                                ],
                                storage: { prim: 'None' },
                                input: { prim: 'Pair', args: [arg, storageValue] },
                                amount: '0',
                                chain_id: chainId,
                                balance: '0'
                            };
                            return [4 /*yield*/, this.rpc.runCode(viewScript)];
                        case 4:
                            result = _b.sent();
                            viewResultSchema = new michelsonEncoder.ParameterSchema(this.returnType);
                            return [2 /*return*/, viewResultSchema.Execute(result.storage.args[0])];
                    }
                });
            });
        };
        return MichelsonStorageView;
    }());

    var ViewFactory = /** @class */ (function () {
        function ViewFactory() {
        }
        ViewFactory.prototype.getView = function (viewName, rpc, contract, viewImplementation) {
            if (this.isMichelsonStorageView(viewImplementation)) {
                var viewValues_1 = viewImplementation[exports.ViewImplementationType.MICHELSON_STORAGE];
                if (!viewValues_1.returnType || !viewValues_1.code) {
                    console.warn(viewName + " is missing mandatory code or returnType property therefore it will be skipped.");
                    return;
                }
                return function () {
                    var view = new MichelsonStorageView(viewName, contract, rpc, viewValues_1.returnType, viewValues_1.code, viewValues_1.parameter);
                    return view;
                };
            }
        };
        ViewFactory.prototype.getImplementationType = function (viewImplementation) {
            return Object.keys(viewImplementation)[0];
        };
        ViewFactory.prototype.isMichelsonStorageView = function (viewImplementation) {
            return this.getImplementationType(viewImplementation) === exports.ViewImplementationType.MICHELSON_STORAGE;
        };
        return ViewFactory;
    }());

    var metadataBigMapType = {
        prim: 'big_map',
        args: [{ prim: 'string' }, { prim: 'bytes' }],
        annots: ['%metadata']
    };
    var Tzip16ContractAbstraction = /** @class */ (function () {
        function Tzip16ContractAbstraction(constractAbstraction, context) {
            this.constractAbstraction = constractAbstraction;
            this.context = context;
            this._viewFactory = new ViewFactory();
            this._metadataViewsObject = {};
            this._metadataProvider = context.metadataProvider;
        }
        Tzip16ContractAbstraction.prototype.findMetadataBigMap = function () {
            var metadataBigMapId = this.constractAbstraction.schema.FindFirstInTopLevelPair(this.constractAbstraction.script.storage, metadataBigMapType);
            if (!metadataBigMapId) {
                throw new BigMapMetadataNotFound();
            }
            return new taquito.BigMapAbstraction(new BigNumber__default['default'](metadataBigMapId['int']), new michelsonEncoder.Schema(metadataBigMapType), this.context.contract);
        };
        Tzip16ContractAbstraction.prototype.getUriOrFail = function () {
            return __awaiter(this, void 0, void 0, function () {
                var metadataBigMap, uri;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            metadataBigMap = this.findMetadataBigMap();
                            return [4 /*yield*/, metadataBigMap.get('')];
                        case 1:
                            uri = _a.sent();
                            if (!uri) {
                                throw new UriNotFound();
                            }
                            return [2 /*return*/, uri];
                    }
                });
            });
        };
        /**
         * @description Return an object containing the metadata, the uri, an optional integrity check result and an optional sha256 hash
         */
        Tzip16ContractAbstraction.prototype.getMetadata = function () {
            return __awaiter(this, void 0, void 0, function () {
                var uri, _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this._metadataProvider) {
                                throw new UnconfiguredMetadataProviderError();
                            }
                            if (!!this._metadataEnvelope) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.getUriOrFail()];
                        case 1:
                            uri = _b.sent();
                            _a = this;
                            return [4 /*yield*/, this._metadataProvider.provideMetadata(this.constractAbstraction, utils.bytes2Char(uri), this.context)];
                        case 2:
                            _a._metadataEnvelope = _b.sent();
                            _b.label = 3;
                        case 3: return [2 /*return*/, this._metadataEnvelope];
                    }
                });
            });
        };
        Tzip16ContractAbstraction.prototype.metadataViews = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(Object.keys(this._metadataViewsObject).length === 0)) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.initializeMetadataViewsList()];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2: return [2 /*return*/, this._metadataViewsObject];
                    }
                });
            });
        };
        Tzip16ContractAbstraction.prototype.initializeMetadataViewsList = function () {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                var metadata, metadataViews;
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.getMetadata()];
                        case 1:
                            metadata = (_b.sent()).metadata;
                            metadataViews = {};
                            (_a = metadata.views) === null || _a === void 0 ? void 0 : _a.forEach(function (view) { return _this.createViewImplementations(view, metadataViews); });
                            this._metadataViewsObject = metadataViews;
                            return [2 /*return*/];
                    }
                });
            });
        };
        Tzip16ContractAbstraction.prototype.generateIndexedViewName = function (viewName, metadataViews) {
            var i = 1;
            if (viewName in metadataViews) {
                while ("" + viewName + i in metadataViews) {
                    i++;
                }
                viewName = "" + viewName + i;
            }
            return viewName;
        };
        Tzip16ContractAbstraction.prototype.createViewImplementations = function (view, metadataViews) {
            var e_1, _a;
            var _b;
            try {
                for (var _c = __values((_b = view === null || view === void 0 ? void 0 : view.implementations) !== null && _b !== void 0 ? _b : []), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var viewImplementation = _d.value;
                    if (view.name) {
                        // when views have the same name, add an index at the end of the name
                        var viewName = this.generateIndexedViewName(view.name, metadataViews);
                        var metadataView = this._viewFactory.getView(viewName, this.context.rpc, this.constractAbstraction, viewImplementation);
                        if (metadataView) {
                            metadataViews[viewName] = metadataView;
                        }
                        else {
                            console.warn("Skipped generating " + viewName + " because the view has an unsupported type: " + this._viewFactory.getImplementationType(viewImplementation));
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        return Tzip16ContractAbstraction;
    }());

    var ABSTRACTION_KEY = Symbol("Tzip16ContractAbstractionObjectKey");
    function tzip16(abs, context) {
        return Object.assign(abs, {
            // namespace tzip16
            tzip16: function () {
                if (!this[ABSTRACTION_KEY]) {
                    this[ABSTRACTION_KEY] = new Tzip16ContractAbstraction(this, context);
                }
                return this[ABSTRACTION_KEY];
            }
        });
    }

    function calculateSHA256Hash(preimage) {
        return CryptoJS__default['default'].SHA256(preimage).toString(CryptoJS__default['default'].enc.Hex);
    }

    /**
     * @description: Metadata Provider
     */
    var MetadataProvider = /** @class */ (function () {
        function MetadataProvider(handlers) {
            this.handlers = handlers;
            this.PROTOCOL_REGEX = /(?:sha256\:\/\/0x(.*)\/)?(https?|ipfs|tezos-storage)\:(.*)/;
        }
        /**
         * @description Fetch the metadata by using the appropriate handler based on the protcol found in the URI
         * @returns an object which contains the uri, the metadata, an optional integrity check result and an optional SHA256 hash
         * @param _contractAbstraction the contract abstraction which contains the URI in its storage
         * @param _uri the decoded uri found in the storage
         * @param context the TezosToolkit Context
         */
        MetadataProvider.prototype.provideMetadata = function (contractAbstraction, uri, context) {
            return __awaiter(this, void 0, void 0, function () {
                var uriInfo, handler, metadata, sha256Hash, metadataJSON;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            uriInfo = this.extractProtocolInfo(uri);
                            if (!uriInfo || !uriInfo.location) {
                                throw new InvalidUri(uri);
                            }
                            handler = this.handlers.get(uriInfo.protocol);
                            if (!handler) {
                                throw new ProtocolNotSupported(uriInfo.protocol);
                            }
                            return [4 /*yield*/, handler.getMetadata(contractAbstraction, uriInfo, context)];
                        case 1:
                            metadata = _a.sent();
                            sha256Hash = calculateSHA256Hash(metadata);
                            try {
                                metadataJSON = JSON.parse(metadata);
                            }
                            catch (ex) {
                                throw new InvalidMetadata(metadata);
                            }
                            return [2 /*return*/, {
                                    uri: uri,
                                    metadata: metadataJSON,
                                    integrityCheckResult: uriInfo.sha256hash ? uriInfo.sha256hash === sha256Hash : undefined,
                                    sha256Hash: uriInfo.sha256hash ? sha256Hash : undefined
                                }];
                    }
                });
            });
        };
        MetadataProvider.prototype.extractProtocolInfo = function (_uri) {
            var extractor = this.PROTOCOL_REGEX.exec(_uri);
            if (!extractor)
                return;
            return {
                sha256hash: extractor[1],
                protocol: extractor[2],
                location: extractor[3]
            };
        };
        return MetadataProvider;
    }());

    var DEFAULT_HANDLERS = new Map([
        ['http', new HttpHandler()],
        ['https', new HttpHandler()],
        ['tezos-storage', new TezosStorageHandler()],
        ['ipfs', new IpfsHttpHandler()]
    ]);
    var Tzip16Module = /** @class */ (function () {
        function Tzip16Module(metadataProvider) {
            this._metadataProvider = metadataProvider ? metadataProvider : new MetadataProvider(DEFAULT_HANDLERS);
        }
        Tzip16Module.prototype.configureContext = function (context) {
            Object.assign(context, { metadataProvider: this._metadataProvider });
        };
        return Tzip16Module;
    }());

    // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
    /* tslint:disable */
    var VERSION = {
        "commitHash": "eb5b2c4973cd11098b68ce62eb6702dea376e569",
        "version": "10.1.1"
    };
    /* tslint:enable */

    Object.defineProperty(exports, 'bytes2Char', {
        enumerable: true,
        get: function () {
            return utils.bytes2Char;
        }
    });
    Object.defineProperty(exports, 'char2Bytes', {
        enumerable: true,
        get: function () {
            return utils.char2Bytes;
        }
    });
    exports.BigMapMetadataNotFound = BigMapMetadataNotFound;
    exports.DEFAULT_HANDLERS = DEFAULT_HANDLERS;
    exports.ForbiddenInstructionInViewCode = ForbiddenInstructionInViewCode;
    exports.HttpHandler = HttpHandler;
    exports.InvalidMetadata = InvalidMetadata;
    exports.InvalidMetadataType = InvalidMetadataType;
    exports.InvalidUri = InvalidUri;
    exports.InvalidViewParameterError = InvalidViewParameterError;
    exports.IpfsHttpHandler = IpfsHttpHandler;
    exports.MetadataNotFound = MetadataNotFound;
    exports.MetadataProvider = MetadataProvider;
    exports.MichelsonStorageView = MichelsonStorageView;
    exports.NoParameterExpectedError = NoParameterExpectedError;
    exports.ProtocolNotSupported = ProtocolNotSupported;
    exports.TezosStorageHandler = TezosStorageHandler;
    exports.Tzip16ContractAbstraction = Tzip16ContractAbstraction;
    exports.Tzip16Module = Tzip16Module;
    exports.UnconfiguredMetadataProviderError = UnconfiguredMetadataProviderError;
    exports.UriNotFound = UriNotFound;
    exports.VERSION = VERSION;
    exports.ViewFactory = ViewFactory;
    exports.calculateSHA256Hash = calculateSHA256Hash;
    exports.tzip16 = tzip16;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=taquito-tzip16.umd.js.map
